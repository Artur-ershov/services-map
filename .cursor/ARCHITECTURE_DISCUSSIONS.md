# Архитектурные обсуждения и идеи

> Внутренний файл для контекста работы с AI. Не коммитить в репозиторий.

## Build-time vs Runtime для SVG

**Обсуждение:** Перенос обработки SVG на build-time вместо runtime fetch/parse

**Текущее состояние:**
- SVG загружаются через `fetch()` runtime
- Обработка `parseSvgAndPrepareCache()` при каждой загрузке этажа
- Рекурсивная обработка `fill="none"` для предотвращения черных квадратов

**Проблема:**
- Элементы SVG без `fill` рендерятся черными при клонировании зон
- Клонирование происходит runtime: `cloneNode()` при перемещении между слоями

**Идея переноса на build-time:**
- Обрабатывать `fill="none"` один раз при генерации данных
- Встраивать обработанный SVG content в `data.js` (для Tilda)
- Разделять статический и интерактивный слои на build-time

**Статус:** Идея обсуждалась, реализация отложена. Архитектура слоев требует доработки.

---

## Разделение слоев карты

**Проблема:** `mapAreasContainer` очищается, но не используется - зоны остаются в `mapBaseLayer`

**Текущее состояние:**
```javascript
// renderMapAreas():
mapAreasContainer.innerHTML = '';  // Очищается
const zone = originalZone.cloneNode(true);
originalZone.parentNode.replaceChild(zone, originalZone);  // Остается в mapBaseLayer!
```

**Правильная архитектура:**
- `mapBaseLayer` - статический слой (фон карты, без событий)
- `mapAreasContainer` - интерактивный слой (клоны зон с событиями)
- Клоны должны перемещаться в `mapAreasContainer`, не заменять оригинал

**Решение:** Переместить клоны в `mapAreasContainer.appendChild(zone)` вместо `replaceChild`

**Статус:** Требует исправления в `renderMapAreas()`

---

## Монолитный vs Модульный подход

**Решение:** Монолитный `app.js` для Tilda

**Почему:**
- Простота интеграции (один файл → один блок в Tilda)
- Нет сборки - просто копировать
- Один HTTP-запрос (лучше производительность)
- Размер приемлемый (~1393 строки)

**Когда переходить на модули:**
- Если проект > 5000 строк
- Если несколько разработчиков
- Если переиспользование кода между проектами

**Статус:** Текущее решение оптимально

---

## Система автоматической документации

**Идея:** AI автоматически добавляет структурированные комментарии, извлекает их в PROJECT_CONTEXT.md

**Подход:**
- Короткие комментарии-метки: `@ARCH`, `@TEMP`, `@CRITICAL`
- Автоматическое извлечение через скрипт
- Обновление PROJECT_CONTEXT.md при синхронизации

**Статус:** Идея задокументирована, реализация отложена

**Принцип:** Минималистичный подход - документировать только "почему", не "что"

---

## Важные конфигурации

**BUILDING_MAP (scripts/sync-csv-to-data.py):**
- Критичная конфигурация для синхронизации
- Маппинг: 'Альфа' → B1, 'Парковка' → B2, 'Бета' → B3
- Не менять без обновления всех сервисов

**buildingFloorStructure:**
- B1: "Корпус Альфа"
- B2: "Парковка" (НЕ "PARKING")
- B3: "Корпус Бета"
- Все корпуса: 11 этажей (1-11)

**Временные решения:**
- `tmp.css` - НЕ УДАЛЯТЬ (локальный шрифт)
- `popupLink.style.display = 'none'` - временно скрыто

---

## Проблемы и решения

**"Черные квадраты" на карте:**
- Решено через runtime обработку `fill="none"`
- Причина: элементы без fill рендерятся черными при клонировании

**mapAreasContainer не используется:**
- Требует исправления: перемещать клоны в `mapAreasContainer`

**Контекст теряется между сессиями:**
- Идея: автоматическая документация через комментарии-метки
- Статус: отложено

---

## Рабочий процесс с AI

**Принцип минималистичного подхода:**
- Документировать только "почему" (неочевидные решения)
- Временные решения - с датой удаления
- Критичные конфигурации - с объяснением "не менять"

**Файлы контекста:**
- Этот файл - обсуждения и идеи (internal)
- README.md - только критичное для проекта
- Код - комментарии-метки для важных решений

**Восстановление контекста:**
- Читать этот файл + README.md в начале сессии
- Использовать комментарии-метки в коде для быстрого понимания





